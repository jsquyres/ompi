#!/usr/bin/env @PYTHON@

import os
import sys

from pprint import pprint

try:
    from configparser import ConfigParser
except ImportError:
    from ConfigParser import ConfigParser  # ver. < 3.0

#------------------------------------------------------------------------

def _resolve(string, configure_values):
    # Loop until we resolve everything
    while True:
        old = string
        for key, value in configure_values.items():
            token = '${' + key + '}'
            if token in string:
                string = string.replace(token, value)

        # If we had no changes this iteration, then we're done
        # resolving everything.
        if old == string:
            return string

# These values come in from configure.
# Must define these in the correct order so that they can be resolved.
# These are prerequisites.
configure_values = {
    'prefix'      : '@prefix@',
    'exec_prefix' : '@exec_prefix@',
    'datarootdir' : '@datarootdir@',
    'datadir'     : '@datadir@',
    'sysconfdir'  : '@sysconfdir@',
}

# These are really the only 2 that we care about.
bindir      = _resolve('@bindir@', configure_values)
sysconfdir  = _resolve('@sysconfdif@', configure_values)

#------------------------------------------------------------------------

# Philosophy this this function:
#
# It's ok for this function to be a little complex.  Put the complexity here in
# this routine to generate a "perfect" config data structure, so that code using
# this config can be as simple as possible.
def load_ompirun_config():
    config = dict()
    ini    = ConfigParser()
    # Allow the config parser to maintain case of section names
    ini.optionxform = str

    # Read the file
    ompirun_ini = os.path.join(sysconfdir, 'ompirun.ini')
    if os.path.exists(ompirun_ini):
        ini.read(ompirun_ini)

    # Go through every section from the config file and add it to the config
    # data structure
    for section in ini.sections():
        # Allow [foo] sections to be synonmous [foo:values]
        section = section.strip()

        if section == "":
            continue

        # We currently only support a single section name: "alias:net".
        # It is anticipated that we may support other sections in the future.
        match = re.search('^alias\s*:\s*net$', section)
        if match is None:
            print(f"Unsupported section in {ompirun_ini}: {section}")
            exit(1)

        # Past all the error checks.  Save this data in the config data
        # structure.
        option = f'--{section}'
        if option not in config:
            config[option] = dict()

        for key, value in ini.items(section):
            # For now, do not allow keys to have spaces
            if ' ' in key:
                print(f'Warning: spaces are not supported in alias keys (skipping "{section}:{item}")')
                continue

            config[option][key] = value.split(' ')

    return config

#------------------------------------------------------------------------

def get_cmd_line():
    options = {
        'show'     : False,
        'showonly' : False,
    }

    # Skip argv[0]
    argv = sys.argv[1:]

    # Look for ompirun-specific CLI parameters
    while len(argv) > 0:
        arg = argv[0]
        if arg.startswith('--') and arg[2:] in options:
            options[arg[2:]] = True
        elif arg == '--':
            argv = argv[1:]
            break
        else:
            break

        argv = argv[1:]

    return argv, options

#------------------------------------------------------------------------

def expand_tune_file(filename):
    if not os.path.exists(filename):
        print(f"Error: --tune file {filename} does not exist")
        exit(1)

    with open(filename) as f:
        lines = f.readlines()

    # Per the man page, --tune files only accept a specific set of lines.
    # Error on any other kind of input line.
    tokens = list()
    for line_num, line in enumerate(lines):
        line_num += 1
        line = line.strip()
        args = line.split(' ')
        if args[0] != '--mca' and args[0] != '-x':
            print(f"Error: unrecognized option in --tune file {filename}:{line_num}: {args[0]} ")
            print("Only --mca and -x options are allowed in --tune files.")
            exit(1)

        tokens.append(args[0])

        # --mca args can be (var val) or (var "val")
        if args[0] == '--mca':
            var   = args[1]
            value = args[2]

            multi_tokens = False
            if value[0] != '"' and len(args) > 3:
                multi_tokens = True

            elif value[0] == '"':
                # If it's a quoted value, then:
                # 0. Start with the original line (to preserve whitespace)
                # 1. Remove the --mca
                # 2. Remove whitespace
                # 3. Remove the variable name
                # 4. Remove whitespace
                # 5. Remove the leading quote
                # 6. Take the rest of the string
                # 7. Remove the trailing quote
                value = line.replace("--mca", "").strip()
                value = value.replace(var, "").strip()
                value = value[1:]
                if value[-1] == '"':
                    value = value[:-1]
                else:
                    multi_tokens = True

            if multi_tokens:
                print(f"Error: --tune file {filename}:{line_num}: MCA value for {var} cannot be multiple tokens without quoting")
                exit(1)

            tokens.append(var)
            tokens.append(value)

        # -x arg can be (var) or (var=val)
        elif args[0] == '-x':
            var = args[1]

            if len(args) > 2:
                print(f"Error: --tune file {filename}:{line_num}: -x option cannot be multiple tokens")
                exit(1)

            tokens.append(var)

    return tokens

#------------------------------------------------------------------------

def expand_tune_args(argv):
    new_argv = list()

    i = 0
    while i < len(argv):
        token = argv[i]

        if token == '--':
            new_argv.extend(argv[i:])
            break

        elif argv[i] == '--tune':
            if (i + 1) >= len(argv):
                print("Error: --tune requires a filename argument")
                exit(1)

            # The --tune option can take a comma-delmited list of files
            i += 1
            filenames = argv[i].split(',')
            for filename in filenames:
                expanded_argv = expand_tune_file(filename)
                new_argv.extend(expanded_argv)

        else:
            new_argv.append(token)

        i += 1

    return new_argv

#------------------------------------------------------------------------

def expand_alias_args(argv, config):
    options  = config.keys()
    new_argv = list()

    i = 0
    while i < len(argv):
        token = argv[i]

        if token == '--':
            new_argv.extend(argv[i:])
            break

        elif token in options:
            # If we find the token in our list of options, then look at the
            # token following this one, and see if it is one of the defined
            # values.
            if i + 1 >= len(argv):
                print(f'Error: argument expected for the "{token}" parameter')
                print('Error: cannot continue')
                exit(1)

            i   = i + 1
            arg = argv[i]
            if arg not in config[token]:
                print(f'Error: undefined option for the "{token}" parameter')
                values = ', '.join(config[token])
                print(f'Error: allowable options are: {values}')
                exit(1)

            # We found a match -- huzzah!
            # Add it to the new arg
            new_argv.extend(config[token][arg])

        else:
            # If this is not a defined option, then just append it to the end of
            # the new argv
            new_argv.append(token)

        i += 1

    return new_argv

#------------------------------------------------------------------------

def find_prte():
    prte = os.path.join(bindir, 'prte')
    if not os.path.exists(prte) or not os.path.isfile(prte) or not os.access(prte, os.X_OK):
        print(f"Cannot find {prte}; aborting")
        exit(1)

    return prte

#------------------------------------------------------------------------

def launch(argv, options):
    base_cmd = os.path.filename(sys.argv[0])
    if base_cmd == 'ompirun-show' or base_cmd == 'ompirun-showonly':
        print(' '.join(argv))
        if base_cmd == 'ompirun-showonly':
            exit(0)

    # Launch and do not return
    os.execvp(argv[0], argv)

#------------------------------------------------------------------------

def main():
    config        = load_ompirun_config()
    argv, options = get_cmd_line()

    # Make these recursive / expand until no more expansion
    new_argv      = expand_tune_args(argv)
    new_argv      = expand_alias_args(new_argv, config)

    # Add the PRTE executable as argv[0]
    prte          = find_prte()
    new_argv.insert(0, prte)

    launch(new_argv, options)
    # Does not return

if __name__ == '__main__':
    main()
